/*
gjcc@cin.ufpe.br: Modified to support Java 8:

Per Sreenivasa Viswanadha (as posted on the javacc user mailing list), the
original java 1.5 grammar is licensed under the BSD license, so this modified
grammar is also.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.
    * Neither the name of the <ORGANIZATION> nor the names of its contributors
    may be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


options {
  /*UNICODE_INPUT = true;*/
  /*JAVA_UNICODE_ESCAPE = false;*/
  JAVA_UNICODE_ESCAPE = true;
  ERROR_REPORTING = true;
  STATIC = false;
}

PARSER_BEGIN(Java18MergeParser)
package de.ovgu.cide.fstgen.parsers.generated_java18_merge;

import java.io.*;
import java.util.*;
import cide.gast.*;
import cide.gparser.*;
import de.ovgu.cide.fstgen.ast.*;

public class Java18MergeParser extends AbstractFSTParser
{
 	public Java18MergeParser(){}
}

PARSER_END(Java18MergeParser)


/********************************************
 * THE JAVA TOKEN SPECIFICATION STARTS HERE *
 ********************************************/

/* WHITE SPACE */

SPECIAL_TOKEN :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
/*| "\ufffd"*/
}

/* COMMENTS */

MORE :
{
  "//" { input_stream.backup(2); } : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  < SINGLE_LINE_COMMENT: "//"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
| < ASSERT: "assert" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < STRICTFP: "strictfp" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
}


TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <BINARY_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] ((["_"])*["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])((["_"])*["0"-"9","a"-"f","A"-"F"])* >      
|
  < #BINARY_LITERAL: "0" ["b","B"] (["0"-"1"])((["_"])*["0"-"1"])* >   
|
  < #OCTAL_LITERAL: "0" ((["_"])*(["0"-"7"]))* >      
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])((["_"])*(["0"-"9"]))* "." ((["0"-"9"])((["_"])*(["0"-"9"]))*)* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])((["_"])*(["0"-"9"]))* (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])((["_"])*(["0"-"9"]))* <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])((["_"])*(["0"-"9"]))* (<EXPONENT>)? ["f","F","d","D"]
  >
  
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","u","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","u","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < AT: "@" >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
| < ELLIPSIS: "..." >
| < POINTER: "->" >
| < DIAMOND: "<>" >

}


TOKEN :
{
		/*< RUNSIGNEDSHIFT: ">>>" >
		{
		matchedToken.kind = GT;
		((Token.GTToken)matchedToken).realKind = RUNSIGNEDSHIFT;
		input_stream.backup(2);
		}
		| < RSIGNEDSHIFT: ">>" >
		{
		matchedToken.kind = GT;
		((Token.GTToken)matchedToken).realKind = RSIGNEDSHIFT;
		input_stream.backup(1);
		}
		|*/
		< GT: ">" >
}




GRAMMARSTART

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/**
 * Main entry point for parsing java files.
 */

@FSTNonTerminal()
CompilationUnit:        
	   [ LOOK_AHEAD("( Annotation() )* \"package\"") PackageDeclaration ]
	   ( ImportDeclaration )*
	   ( TypeDeclaration )*
	   <EOF>
;

PackageDeclaration:  
		( Annotation )* <PACKAGE> Name ";" @!
;

@FSTTerminal(name="{Name}{ImportPackage}")
ImportDeclaration:  
        <IMPORT> [ "static" <NONE>] Name [ ImportPackage ] ";" @!
;

@FSTExportName(".*")
ImportPackage:
		<NONE> "." "*" 
;

@FSTTerminal()
Modifiers:
		( LOOK_AHEAD(2) Modifier )*
;

Modifier:
		<PUBLIC> <NONE>
		|
		<STATIC> <NONE>
		|
		<PROTECTED> <NONE>
		|
		<PRIVATE> <NONE>
		|
		<FINAL> <NONE>
		|
		<ABSTRACT> <NONE>
		|
		<SYNCHRONIZED> <NONE>
		|
		<NATIVE> <NONE>
		|
		<TRANSIENT> <NONE>
		|
		<VOLATILE> <NONE>
		|
		<STRICTFP> <NONE>
		|
		<_DEFAULT> <NONE>
		|
		Annotation
;

@FSTTerminal(name="{<IDENTIFIER>}")
Id: 	<IDENTIFIER>;

/*
 * Declaration syntax follows.
 */

// Handle classes, interfaces, enums, and annotations.
TypeDeclaration:
		@FSTTerminal(name="{AUTO}")	
		";"<NONE> :: EmptyTypeDecl
		|	
		@FSTNonTerminal(name="{AnnotationTypeDeclaration}")
		LOOK_AHEAD("Modifiers() \"@\" \"interface\"") Modifiers @~ AnnotationTypeDeclaration ::  AnnotationTypeDecl
		|
		@FSTNonTerminal(name="{Id}")
		LOOK_AHEAD("Modifiers() \"enum\"") Modifiers @~ EnumDeclaration :: EnumDecl
		|
		@FSTNonTerminal(name="{Id}")
		Modifiers ClassOrInterfaceDeclaration :: ClassOrInterfaceDecl
;

@FSTInline
ClassOrInterfaceDeclaration:  
		[FinalOrAbstract] ClassOrInterface
		Id
		[ TypeParameters ]
		[ ExtendsList ]
		[ ImplementsList ]
		ClassOrInterfaceBody
		[ LOOK_AHEAD(2) <SEMICOLON> ]
;

@FSTTerminal()
ClassOrInterface: 
			"class"<NONE> :: ClassOrInterface
			| 
			"interface"<NONE> :: ClassOrInterface
;

@FSTTerminal(name="ExtndList")
ExtendsList:
       "extends" &LI ClassOrInterfaceTypeAnnotation ( "," &LI ClassOrInterfaceTypeAnnotation )*
;

@FSTTerminal(name="ImplList")
ImplementsList:  
		"implements" &LI ClassOrInterfaceTypeAnnotation ( "," &LI ClassOrInterfaceTypeAnnotation )*
;

ClassOrInterfaceTypeAnnotation:
	(Annotation)* ClassOrInterfaceType
;

@FSTInline 
EnumDeclaration:  
        "enum" Id
        [ ImplementsList ]
        EnumBody
;

@FSTInline 
EnumBody:  
		"{"
		[EnumConstants]
		["," <NONE>]
		[ EnumBodyInternal ]
		"}"
;

@FSTNonTerminal()
EnumBodyInternal: 
		";" @+ @! ( ClassOrInterfaceBodyDeclaration )* @- @!
;

@FSTNonTerminal()
EnumConstants: 
		&LI EnumConstant ( LOOK_AHEAD(2) "," &LI EnumConstant )* 
;

@FSTNonTerminal(name="{Id}")
EnumConstant: 
        ( Annotation )* Id [ Arguments ] [ ClassOrInterfaceBody ]
;

@FSTTerminal(name="TypeParameters", merge="LineBased")
TypeParameters:   
		"<" (TypeParameter)? ("," TypeParameter )* ">"
;

TypeParameter:
		( Annotation )* Id [ TypeBound ]       
;

TypeBound:   
		"extends" ClassOrInterfaceType ( "&" ClassOrInterfaceType )*       
;

@FSTNonTerminal()
ClassOrInterfaceBody:
		"{" @+ @! ( ClassOrInterfaceBodyDeclaration)* @- @! "}"
;

ClassOrInterfaceBodyDeclaration:
		@FSTTerminal(name="{AUTO}")
		LOOK_AHEAD(2)
		Initializer :: InitializerDecl
		|
		@FSTNonTerminal(name="{Id}")
		LOOK_AHEAD("Modifiers() ClassOrInterface()")
		Modifiers ClassOrInterfaceDeclaration :: InnerClassDecl
		|
		@FSTNonTerminal(name="{Id}")
		LOOK_AHEAD("Modifiers() \"enum\"")
		Modifiers @~ EnumDeclaration :: InnerEnumDecl
		|
		@FSTNonTerminal(name="{ConstructorDeclaration}")
		LOOK_AHEAD("Modifiers() [ TypeParameters() ] Id() \"(\"")
		Modifiers ConstructorDeclaration :: ConstructorDecl
		|
		@FSTNonTerminal(name="{FieldDeclaration}")
		LOOK_AHEAD( " Modifiers() Type() Id() ( \"[\" \"]\" )* ( \",\" | \"=\" | \";\" ) ")
		Modifiers FieldDeclaration :: FieldDecl
		|
		@FSTNonTerminal(name="{AnnotationTypeDeclaration}")
		LOOK_AHEAD("Modifiers() \"@\" \"interface\"")
		Modifiers @~ AnnotationTypeDeclaration :: InnerAnnotationTypeDecl
		|
		@FSTNonTerminal(name="{MethodDeclaration}")
		LOOK_AHEAD(2)
		Modifiers MethodDeclaration :: MethodDecl
		|
		@FSTTerminal(name="{AUTO}")
		";" <NONE> :: EmptyDecl
;

@FSTExportName("{VariableDeclarator}")
@FSTNonTerminal()
FieldDeclaration:  
		Type &LI VariableDeclarator ("," &LI VariableDeclarator)* ";"
;

@FSTNonTerminal(name="{VariableDeclaratorId}")
VariableDeclarator:
		VariableDeclaratorId [ "=" VariableInitializer ]
;

@FSTExportName("{Id}")
VariableDeclaratorId:  
		LOOK_AHEAD(2) Id "." <THIS> 
		| 
		<THIS>
        |
		Id ( "[" "]" <NONE> )*
;

@FSTNonTerminal()
VariableInitializer:   
		ArrayInitializer :: VariableInitializerArray
		|
		Expression :: VariableInitializerExpression
;

ArrayInitializer:
		"{" [ ArrayInitializerInternal ] [ "," <NONE> ] "}"
;

@FSTNonTerminal()
ArrayInitializerInternal:
		VariableInitializer ( LOOK_AHEAD(2) "," VariableInitializer )*
;

@FSTExportName("{MethodDeclarator}")
@FSTNonTerminal()
MethodDeclaration:   
		[ TypeParameters ]
		ResultType
		MethodDeclarator [@~ "throws" NameList ]
		MethodDeclarationBody
;

@FSTNonTerminal()
MethodDeclarationBody: 
		Block :: MethodDeclarationBodyBlock
        | 
        ";"<NONE> :: MethodDeclarationBodyNone
; 

@FSTExportName("{Id}({FormalParameters})")
@FSTTerminal(name="{Id}({FormalParameters})")
MethodDeclarator:
		Id FormalParameters ( "[" "]" <NONE>)*
;

@FSTExportName("{FormalParametersInternal}")
FormalParameters:
	"("[FormalParametersInternal]")"
;

@FSTExportName("{FormalParameter}^-")
FormalParametersInternal:
		&LI FormalParameter ("," &LI FormalParameter)*
;

@FSTExportName("{Type}")
FormalParameter:
		Modifiers
		(FinalOrAnnotation)*
		Type
		[ "..."<NONE> ]
		VariableDeclaratorId
;

FinalOrAnnotation:
		"final" <NONE> | Annotation
;

@FSTExportName("{ConstructorDeclarator})")
@FSTNonTerminal()
ConstructorDeclaration:
		[ LOOK_AHEAD("Annotation()") Annotation ]
		[ TypeParameters]
		ConstructorDeclarator [@~ "throws" NameList ]
		ConstructorDeclarationBody
;

@FSTExportName("{Id}({FormalParameters})")
@FSTTerminal(name="{Id}({FormalParameters})")
ConstructorDeclarator:
		Id FormalParameters
;

ExplicitConstructorInvocation:
        @FSTNonTerminal()
		LOOK_AHEAD("\"this\" Arguments() \";\"") "this" Arguments ";" @! :: ExplicitConstructorInvocationThisArguments
		|
        @FSTNonTerminal()
		LOOK_AHEAD("TypeArguments() \"this\" Arguments() \";\"") TypeArguments "this" Arguments ";" @! :: ExplicitConstructorInvocationThisTypeArguments
		|
        @FSTNonTerminal()
		[LOOK_AHEAD("PrimaryExpression() \".\"") PrimaryExpression "." ] [ TypeArguments ] "super" Arguments ";" @! :: ExplicitConstructorInvocationSuper
;

@FSTNonTerminal()
ConstructorDeclarationBody:
		"{" @+!
		[ LOOK_AHEAD("ExplicitConstructorInvocation()")  ExplicitConstructorInvocation ]
		( BlockStatement )*
		 @- "}"
;


Initializer:  
        [ "static" <NONE>] Block
;

@FSTExportName("{TOSTRING}")
Type:
		LOOK_AHEAD(2) ReferenceType
		|
		PrimitiveType
;

ReferenceType:
		LOOK_AHEAD(3) PrimitiveType ( LOOK_AHEAD(2) "[" "]" <NONE> )+
		|
		ClassOrInterfaceType ( LOOK_AHEAD(2) "[" "]" <NONE>)*
;


@FSTTerminal(name="{TOSTRING}")
ClassOrInterfaceType:
		Id [ LOOK_AHEAD(2) TypeArguments ]
		( LOOK_AHEAD(2) ClassOrInterfaceTypeInternal)*
;

ClassOrInterfaceTypeInternal:
		"." Id [ LOOK_AHEAD(2) TypeArguments]
;

TypeArguments: 
         <DIAMOND>   
        |
        "<" &LI TypeArgument ( ","  &LI TypeArgument )* ">"
;

TypeArgument:
		(Annotation)* ReferenceType
		|
		"?" [ WildcardBounds ]
;

WildcardBounds:
		"extends" (Annotation)* ReferenceType
		|
		"super" (Annotation)* ReferenceType 
;

PrimitiveType:
		"boolean"<NONE>
		|
		"char"<NONE>
		| 
		"byte"<NONE>
		| 
		"short" <NONE>
		| 
		"int"<NONE>
		| 
		"long"<NONE>
		| 
		"float"<NONE>
		| 
		"double" <NONE>
;

ResultType:
		"void" <NONE>
		|
		Type
;

@FSTExportName("{Id}^.")
Name:
        Id
        (LOOK_AHEAD(2) "." Id )*
;

NameList:
        &LI NameListAnnotation ( "," &LI NameListAnnotation )*   
;

NameListAnnotation:
	(Annotation)* Name
;

/*
 * Expression syntax follows.
 */

@FSTNonTerminal()
Expression:  
			  ConditionalExpression
			  [ LOOK_AHEAD(2) AssignmentExpression]
;
@FSTNonTerminal()
AssignmentExpression:
			AssignmentOperator Expression
;

AssignmentOperator:
  "=" <NONE> | "*=" <NONE> | "/=" <NONE> | "%=" <NONE> | "+=" <NONE> | "-=" <NONE>| "<<=" <NONE> | ">>=" <NONE> | ">>>=" <NONE> | "&=" <NONE> | "^=" <NONE> | "|=" <NONE>
;

@FSTNonTerminal()
ConditionalExpression:   
			LOOK_AHEAD("ConditionalOrExpression() \"?\"") 
			ShortIf{Expression}
			|
			ConditionalOrExpression
;

@FSTNonTerminal()
ShortIf:
			ShortIfInternal ":" Expression 
;

@FSTNonTerminal()
ShortIfInternal:
			ConditionalOrExpression "?" Expression!
;

@FSTNonTerminal()
ConditionalOrExpression:
			&LI ConditionalAndExpression ( LOOK_AHEAD(2) "||" &LI ConditionalAndExpression)*
;

@FSTNonTerminal()
ConditionalAndExpression:  
			&LI InclusiveOrExpression ( LOOK_AHEAD(2) "&&" &LI InclusiveOrExpression )*
;

@FSTNonTerminal()
InclusiveOrExpression:
			&LI ExclusiveOrExpression ( LOOK_AHEAD(2) "|" &LI ExclusiveOrExpression )*
;

@FSTNonTerminal()
ExclusiveOrExpression:    
			&LI AndExpression ( LOOK_AHEAD(2) "^" &LI AndExpression )*
;

@FSTNonTerminal()
AndExpression:   
			&LI EqualityExpression ( LOOK_AHEAD(2) "&" &LI EqualityExpression )*
;

@FSTNonTerminal()
EqualityExpression: 
			InstanceOfExpression ( LOOK_AHEAD(2) EqualityExpressionInternal )*
;
@FSTNonTerminal()
EqualityExpressionInternal: 
			EqualityOp InstanceOfExpression
;

EqualityOp:  
			"=="<NONE> | "!="<NONE>
;


@FSTNonTerminal()
InstanceOfExpression:
			RelationalExpression [ LOOK_AHEAD(2) "instanceof" Type ]
;

@FSTNonTerminal()
RelationalExpression:
			ShiftExpression ( LOOK_AHEAD(2) RelationalExpressionInternal )*
;

@FSTNonTerminal()
RelationalExpressionInternal:
			RelationalOp ShiftExpression
;

RelationalOp: 
			"<"<NONE> | ">"<NONE> | "<=" <NONE>| ">="<NONE>
;

@FSTNonTerminal()
ShiftExpression:
			AdditiveExpression ( LOOK_AHEAD(2) ShiftExpressionInternal )*
;

@FSTNonTerminal()
ShiftExpressionInternal:
			ShiftOp AdditiveExpression
;

ShiftOp:
			//"<<" <NONE> | LOOK_AHEAD(3) RSIGNEDSHIFT |  RUNSIGNEDSHIFT
			"<<" <NONE> 
			| LOOK_AHEAD(3) ">" ">" ">" <NONE> 
			| LL(2) ">" ">" <NONE>		
;

@FSTNonTerminal()
AdditiveExpression:
			MultiplicativeExpression ( LOOK_AHEAD(2) AdditiveExpressionInternal )*
;

@FSTNonTerminal()
AdditiveExpressionInternal:
			AdditiveOp MultiplicativeExpression
;

AdditiveOp:
			"+" <NONE> | "-" <NONE>
;

@FSTNonTerminal()
MultiplicativeExpression:
			UnaryExpression ( LOOK_AHEAD(2) MultiplicativeExpressionInternal )*
;

@FSTNonTerminal()
MultiplicativeExpressionInternal:
			MultiplicativeOp UnaryExpression
;

MultiplicativeOp:
			"*" <NONE> | "/" <NONE> | "%" <NONE> 
;


@FSTNonTerminal()
UnaryExpression: 
			AdditiveOp UnaryExpression :: UnaryExpressionAdditive
			|
			PreIncrementExpression  :: UnaryPreIncrement
			| 
			PreDecrementExpression  :: UnaryPreDecrement
			| 
			UnaryExpressionNotPlusMinus  :: UnaryExpNotPlusMinus
;
@FSTNonTerminal()
PreIncrementExpression:
			"++" PrimaryExpression
;
@FSTNonTerminal()
PreDecrementExpression:
			"--" PrimaryExpression
;
@FSTNonTerminal()
UnaryExpressionNotPlusMinus:
			UnaryOp UnaryExpression :: UnaryExpressionNotPlusMinusUnaryOp
			|
			LOOK_AHEAD( "CastLOOK_AHEAD()" ) 
			CastExpression :: UnaryExpressionNotPlusMinusCastExpression
			|
			PostfixExpression :: UnaryExpressionNotPlusMinusPostfixExpression
;

UnaryOp:	
		"~" <NONE> | "!" <NONE>
;


CastLOOK_AHEAD:   
		LOOK_AHEAD(2)
		"(" PrimitiveType
		|
		LOOK_AHEAD("\"(\" Type() \"[\"")
		"(" Type "[" "]"
		|
		"(" Type ")" CastLOOK_AHEADOp
;

CastLOOK_AHEADOp: 
		"~"<NONE> | "!"<NONE> | "(" <NONE>| "this"<NONE> | "super"<NONE> | "new"<NONE> | <IDENTIFIER> |
		Literal
;

@FSTNonTerminal()
PostfixExpression:
        PrimaryExpression [ LOOK_AHEAD(2) PostfixOp ]
;

PostfixOp:
		"++" <NONE> | "--" <NONE>
;

@FSTNonTerminal()
CastExpression:
		LOOK_AHEAD("\"(\" (Annotation())* Type() \")\"")
		"(" (Annotation)* Type ")" UnaryExpression
		| 
		LOOK_AHEAD("\"(\" (Annotation())* Type() \"&\"") "(" (Annotation)* Type ( "&" ReferenceType)+ ")" UnaryExpressionNotPlusMinus
		|
		"(" (Annotation)* Type ")" UnaryExpressionNotPlusMinus
;

@FSTNonTerminal()
PrimaryExpression:
        PrimaryPrefix  ( LOOK_AHEAD(2) PrimarySuffix )*
;

MemberSelector:
		"." TypeArguments Id
		| 
		MethodReference
;

MethodReference:
		"::" NewOrIdentifier
;

NewOrIdentifier:
		"new"  | Id 
;


PrimaryPrefix:
		@FSTTerminal()
		Literal
		| 
		@FSTTerminal()
		LOOK_AHEAD(2) "this" <NONE>
		| 
		@FSTTerminal()
		"super"  <NONE>
		| 
		@FSTNonTerminal()
		LOOK_AHEAD(" \"(\" \")\" \"->\" ") LambdaExpression
		| 
		@FSTNonTerminal()
		LOOK_AHEAD(" Id() \"->\" ") LambdaExpression
		| 
		@FSTNonTerminal()
		LOOK_AHEAD(" \"(\" VariableDeclaratorId() \")\" \"->\" ") LambdaExpression
		| 
		@FSTNonTerminal()
		LOOK_AHEAD(" \"(\" VariableDeclaratorId() \",\" VariableDeclaratorId() [\",\" VariableDeclaratorId()] \")\" \"->\" ") LambdaExpression
		| 
		@FSTNonTerminal()
		LOOK_AHEAD(" \"(\" FormalParameter() \")\" \"->\" ") LambdaExpression
		| 
		@FSTNonTerminal()
		LOOK_AHEAD(" \"(\" FormalParameter() \",\" FormalParameter() [\",\" FormalParameter() ] \")\" \"->\" ") LambdaExpression
		| 
		@FSTNonTerminal()
		LOOK_AHEAD(" LambdaExpression() ") LambdaExpression
		| 
		@FSTNonTerminal()
		LOOK_AHEAD(3) "(" Expression ")"
		| 
		@FSTNonTerminal()
		AllocationExpression
		| 
		@FSTTerminal()
		LOOK_AHEAD(" ResultType() \".\" \"class\" ") ResultType "." "class"
		| 
		@FSTTerminal()
		LOOK_AHEAD(" Name() \"::\" ") Name
		| 
		@FSTNonTerminal()
		LOOK_AHEAD(" ReferenceType() MethodReference() ") ReferenceType MethodReference
		| 
		@FSTTerminal()
		Name
;

@FSTNonTerminal()
LambdaExpression:
		VariableDeclaratorId "->" ExpressionOrBlock
		| 
		LOOK_AHEAD(3) FormalParameters "->" ExpressionOrBlock
		| 
		LOOK_AHEAD(3) "(" &LI VariableDeclaratorId ( "," &LI VariableDeclaratorId )* ")" "->" ExpressionOrBlock
;

@FSTNonTerminal()
ExpressionOrBlock:
		Expression | Block 
;

PrimarySuffix:
		@FSTTerminal()
		LOOK_AHEAD(2) "." "this" <NONE>
		|
		@FSTTerminal()
		LOOK_AHEAD(2) "." "super" <NONE>
		|
		@FSTNonTerminal()
		LOOK_AHEAD(2) "." AllocationExpression
		|
		@FSTNonTerminal()
		LOOK_AHEAD(3) MemberSelector
		|
		@FSTNonTerminal()
		"[" Expression "]"
		|
		@FSTTerminal()
		"." Id
		|
		@FSTNonTerminal()
		Arguments
;

Literal:   
		<INTEGER_LITERAL>
		|
		<FLOATING_POINT_LITERAL>
		|
		<CHARACTER_LITERAL>
		|
		<STRING_LITERAL>
		|
		BooleanLiteral
		|
		NullLiteral
;

BooleanLiteral:
		"true" <NONE>
		|
		"false" <NONE>
;

NullLiteral:
		"null" <NONE>
;

@FSTNonTerminal()
Arguments:
        "(" [ ArgumentList ] ")"
;
@FSTNonTerminal()
ArgumentList:
        &LI Expression ( "," &LI  Expression )*
;
@FSTNonTerminal()
AllocationExpression:   
		LOOK_AHEAD(3) @~ "new" (Annotation)* PrimitiveType ArrayDimsAndInits :: AllocationExpressionArray
		|
		@~ "new" (Annotation)* ClassOrInterfaceType [ TypeArguments ] AllocationExpressionInit :: AllocationExpressionType
;
@FSTNonTerminal()
AllocationExpressionInit:
		ArrayDimsAndInits :: AllocationExpressionInitArrayDimsAndInits
		|
		Arguments [ ClassOrInterfaceBody ] :: AllocationExpressionInitArguments
;

@FSTNonTerminal()
ArrayDimsAndInits:    
		LOOK_AHEAD(2)
		( LOOK_AHEAD(2) ArrayDims )+ ( LOOK_AHEAD(2) "[" "]" <NONE>)*
		|
		( "[" "]" <NONE>)+ ArrayInitializer
;
@FSTNonTerminal()
ArrayDims:
		"["  Expression "]"
;

/*
 * Statement syntax follows.
 */


Statement:
		@FSTNonTerminal()
		LOOK_AHEAD(2) LabeledStatement :: LabeledStmt
		|
		@FSTNonTerminal()
		AssertStatement :: AssertStmt
		|
		@FSTNonTerminal()
		Block :: BlockStmt
		|
		@FSTTerminal()
		EmptyStatement :: EmptyStmt
		|
		@FSTNonTerminal()
		StatementExpression ";" :: StatementExp
		|
		@FSTNonTerminal()
		SwitchStatement :: SwitchStmt
		|
		@FSTNonTerminal()
		IfStatement :: IfStmt
		|
		@FSTNonTerminal()
		WhileStatement :: WhileStmt
		|
		@FSTNonTerminal()
		DoStatement :: DoStmt
		|
		@FSTNonTerminal()
		ForStatement :: ForStmt
		|
		@FSTTerminal()
		BreakStatement :: BreakStmt
		|
		@FSTTerminal()
		ContinueStatement :: ContinueStmt
		|
		@FSTNonTerminal()
		ReturnStatement :: ReturnStmt
		|
		@FSTNonTerminal()
		ThrowStatement :: ThrowStmt
		|
		@FSTNonTerminal()
		SynchronizedStatement :: SynchronizedStmt
		|
		@FSTNonTerminal()
		TryStatement :: TryStmt
;

@FSTNonTerminal()
AssertStatement:
        "assert" &LI Expression [ ":" &LI Expression ] ";"
;

@FSTNonTerminal()
LabeledStatement:    
		Id ":" Statement
;

@FSTNonTerminal()
Block:
        "{" ( BlockStatement )* "}" 
;

@FSTNonTerminal()
BlockStatement:
		@! @+ [LOOK_AHEAD(2) Annotation] BlockStatementInternal @- @!
;

@FSTNonTerminal()
BlockStatementInternal:
		LOOK_AHEAD("[Annotation()] [FinalOrAbstract()] \"class\"") 
		[Annotation] ClassOrInterfaceDeclaration :: BlockClassOrInterfaceDecl
		|
		LOOK_AHEAD(" Modifiers() (FinalOrAnnotation())* Type() Id()")
		LocalVariableDeclaration ";" :: BlockLocalVariableDecl
		|
		LOOK_AHEAD(3) AssertStatement :: BlockAssertStmt
		|
		LOOK_AHEAD(3) Statement :: InnerBlockStmt
;

FinalOrAbstract:
	<FINAL> <NONE> | <ABSTRACT> <NONE>
;

@FSTNonTerminal()
LocalVariableDeclaration:
		[LOOK_AHEAD(2) Annotation] Modifiers (FinalOrAnnotation)* Type  &LI VariableDeclarator ( "," &LI VariableDeclarator )*
;

EmptyStatement:
		";" <NONE>
;

@FSTNonTerminal()
StatementExpression:
		PreIncrementExpression :: PreIncrementStmtExp
		|
		PreDecrementExpression ::  PreDecrementStmtExp
		|
		/*LOOK_AHEAD( "PrimaryExpression() PostfixOp()" ) PostfixExpression
		|*/
		PrimaryExpression [ StatementExpressionAssignment ] :: AssignmentStmtExp
;

StatementExpressionAssignment:
			@FSTTerminal()
            "++" <NONE> :: Increment
          |
			@FSTTerminal()
            "--" <NONE> :: Decrement
          |
			@FSTNonTerminal()
            AssignmentOperator Expression :: Assignment
;

@FSTNonTerminal()
SwitchStatement:    
		"switch" "(" Expression ")" "{" @! @+ ( SwitchStatementLabel )* @- @! "}"
;

@FSTNonTerminal()
SwitchStatementLabel:
		SwitchLabel ( LOOK_AHEAD(2) BlockStatement )* 
;

SwitchLabel:
		@FSTNonTerminal()
		"case" Expression ":" :: CaseSwitchExp
		|
		@FSTTerminal()
		"default" ":" <NONE> :: DefaultSwitch
;


EnumConstantName:
		<IDENTIFIER>
;

@FSTNonTerminal()
IfStatement:    
        "if" "(" Expression ")" Statement! [ LOOK_AHEAD(1) IfStatementInternal]
;

@FSTNonTerminal()
IfStatementInternal:
	"else" @~ Statement
;

@FSTNonTerminal()
WhileStatement:
		"while" "(" Expression ")" Statement!
;

@FSTNonTerminal()
DoStatement:  
        "do" Statement! "while" "(" Expression ")" ";"
;

@FSTNonTerminal()
ForStatement:
		"for" "(" ForStatementInternal ")" Statement!
;

@FSTNonTerminal()
ForStatementInternal:
		LOOK_AHEAD("[Annotation()][\"final\"] Type() Id() \":\"")
		[LOOK_AHEAD(2) Annotation] ["final" <NONE>] Type Id ":" Expression :: ForEach
		|
		[ ForInit ] ";" [ Expression ] ";" [ ForUpdate ] :: ForTraditional
;

VariableModifier:
		[LOOK_AHEAD(2) Annotation] ["final" <NONE>]   
;

@FSTNonTerminal()
ForInit:
		LOOK_AHEAD(" [ \"final\" ] Type() Id() ")
		LocalVariableDeclaration 
		|
		StatementExpressionList 
;

@FSTNonTerminal()
StatementExpressionList:
        &LI StatementExpression ( "," &LI StatementExpression )*
;

@FSTNonTerminal()
ForUpdate:
        StatementExpressionList
;

@FSTNonTerminal()
BreakStatement:
		"break" [ Id ] ";"
;

@FSTNonTerminal()
ContinueStatement:
		"continue" [ Id ] ";"
;

@FSTNonTerminal()
ReturnStatement:
        "return" [ Expression ] ";"
;

@FSTNonTerminal()
ThrowStatement:
		"throw" Expression ";"
;

@FSTNonTerminal()
SynchronizedStatement:
       "synchronized" "(" Expression ")" Statement!
;

@FSTNonTerminal()
TryStatement:
		"try" (ResourceSpecification)? Block! (LOOK_AHEAD(2) CatchStatement @!)* [LOOK_AHEAD(2) FinallyStatement ]
;

@FSTNonTerminal()
ResourceSpecification:
		"(" Resources (LOOK_AHEAD(2) ";" <NONE>)? ")"	
;

@FSTNonTerminal()
Resources:
		&LI Resource (LOOK_AHEAD(2) ";" &LI Resource)*
;

@FSTNonTerminal()
Resource:
		( FinalOrAnnotation )*
		Type
		VariableDeclaratorId
		"="
		Expression
;

@FSTNonTerminal()
CatchStatement:
		"catch" "(" CatchBlockInternal ")" Statement!
;

@FSTNonTerminal()
CatchBlockInternal:
		LOOK_AHEAD(3) FormalParameter  :: SingleCatching
		|
		&LI ClassOrInterfaceType (LOOK_AHEAD(2) "|" &LI ClassOrInterfaceType)+ VariableDeclaratorId :: MultipleCatching
;

@FSTNonTerminal()
FinallyStatement:
		"finally" Statement!
;

/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */

/*
RUNSIGNEDSHIFT:
		//LOOK_AHEAD("JAVA( \"{ getToken(1).kind == GT && getToken(1) instanceof Token.GTToken && ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT}\")")
		">" ">" ">" <NONE>
;

RSIGNEDSHIFT:
		//LOOK_AHEAD("JAVA(\"{ getToken(1).kind == GT && getToken(1) instanceof Token.GTToken && ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT}\")")
		">" ">" <NONE>
;*/



/* Annotation syntax follows. */

Annotation:
		LOOK_AHEAD( "\"@\" Name() \"(\" ( Id() \"=\" | \")\" )")
		NormalAnnotation
		|
		LOOK_AHEAD("\"@\" Name() \"(\"")
		SingleMemberAnnotation
		|
		MarkerAnnotation
;

NormalAnnotation:
        "@" Name "(" [ MemberValuePairs ] ")" @!
;

MarkerAnnotation:
        "@" Name @!
;

SingleMemberAnnotation:    
        "@" Name "(" MemberValue")" @!
;

MemberValuePairs:    
		MemberValuePair ( "," MemberValuePair)*
;

MemberValuePair:    
		Id "=" MemberValue
;

@FSTNonTerminal()
MemberValue:
		LOOK_AHEAD(2)
		Annotation  :: MemberValueAnnotation
		|
		MemberValueArrayInitializer :: MemberValueArrayInitl
		|
		ConditionalExpression :: MemberValueConditionalExp
;

MemberValueArrayInitializer:    
		"{" ( MemberValueArrayInitializerInternal )? "}"
;

MemberValueArrayInitializerInternal:
		MemberValueList [ "," <NONE>]
;

MemberValueList:
		MemberValue ( LOOK_AHEAD(2) "," MemberValue )*
;

/* Annotation Types. */
@FSTNonTerminal()
@FSTExportName("{Id}")
AnnotationTypeDeclaration: 
        "@" "interface" Id AnnotationTypeBody
;


@FSTInline
AnnotationTypeBody:    
		"{" ( AnnotationTypeMemberDeclaration )* @! "}"
;

AnnotationTypeMemberDeclaration:
		@FSTNonTerminal(name="{Id}")
		LOOK_AHEAD("Modifiers() Type() Id() \"(\"")
		Modifiers Type Id "(" ")" [ DefaultValue ] ";" 
		|
		@FSTNonTerminal(name="{Id}")
		LOOK_AHEAD("Modifiers() ClassOrInterface()")
		Modifiers ClassOrInterfaceDeclaration :: AnnotationInnerClassDecl
		|
		@FSTNonTerminal(name="{Id}")
		LOOK_AHEAD("Modifiers() \"enum\"")
		Modifiers @~ EnumDeclaration :: AnnotationInnerEnumDecl
		|
     	@FSTNonTerminal(name="{AnnotationTypeDeclaration}")
		LOOK_AHEAD("Modifiers() \"@\" \"interface\"")
		Modifiers @~ AnnotationTypeDeclaration :: AnnotationInnerTypeDecl
		|
		@FSTNonTerminal(name="{FieldDeclaration}")
		Modifiers FieldDeclaration :: AnnotationInnerFieldDecl 
		|
		@FSTTerminal(name="{AUTO}")
		";" <NONE> :: AnnoationEmptyDecl
;
@FSTNonTerminal()
DefaultValue:    
        "default" MemberValue
;

